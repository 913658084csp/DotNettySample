## 一个基于WPF + DotNetty的TCP长连接小示例

DotNetty是微软团队参考Java上的Netty开发的网络通信框架，并且保留了Netty原来绝大部分的编程接口。但目前最大的问题是没有官方说明文档，官方示例也仅仅是控制台应用程序，参考价值较低。本项目展示了在WPF中DotNetty的基本使用方法。

DotNetty的GitHub地址：https://github.com/azure/dotnetty

**实现功能：**

- 心跳检测
- 断线重连

**引用类库：**

- DotNetty.Buffers：对内存缓冲区管理的封装
- DotNetty.Codecs：对编解码的封装，包括一些基础基类的实现
- DotNetty.Common：公共的类库项目，包装线程池，并行任务和常用帮助类的封装
- DotNetty.Handlers：封装了常用的管道处理器，比如tls编解码，超时机制，心跳检查，日志等
- DotNetty.Transport：DotNetty核心的实现
- protobuf-net：Protocol Buffers .Net操作类库

**粘包/拆包**

一般所谓的TCP粘包是在一次接收数据不能完全地体现一个完整的消息数据。TCP通讯存在粘包的主要原因是TCP是以流的方式来处理数据，所以就会引发一次接收的数据无法满足消息的需要，导致粘包的存在。处理粘包的唯一方法就是制定应用层的数据通讯协议，通过协议来规范现有接收的数据是否满足消息数据的需要。

解决办法：

          1. 消息定长：报文大小固定长度，不够空格补全，发送和接收方遵循相同的约定，这样即使粘包了通过接收方编程实现获取定长报文也能区分。
          2. 包尾添加特殊分隔符：例如每条报文结束都添加回车换行符（例如FTP协议）或者指定特殊字符作为报文分隔符，接收方通过特殊分隔符切分报文区分。
          3. 将消息分为消息头和消息体：消息头中包含表示信息的总长度（或者消息体长度）的字段

**另外**

更高级的应用请参考《Netty实战》

另外[SuperSocket](https://github.com/tangming579/SuperSocketDemo)是另一个比较好用的.Net通讯框架，也很推荐